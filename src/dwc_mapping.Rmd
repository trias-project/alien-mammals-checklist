---
title: "Darwin Core mapping"
subtitle: "For: Checklist of alien mammals in Belgium"
author:
- Lien Reyserhove
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: true
    toc: true
    toc_depth: 3
    toc_float: true
---

This document describes how we map the checklist data to Darwin Core. 

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(digest)         # To generate hashes
```

# Read source data

The data is maintained in [this Google Spreadsheet](https://docs.google.com/spreadsheets/d/1lqGylVY4SL4AuW3mKxEmHYXEFppUMaM-FLplKzAJ2t0/edit#gid=0).

Read the relevant worksheet (published as csv):

```{r read_source_data}
input_data <- read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vTpIbZpKCr25l-1PuUuSP8Jk191uwZtTXy5HvXJ7P8ZCPNDitkicpQhwKmnfymeo9ERV2n6pbsrOWQG/pub?gid=0&single=true&output=csv", col_types = cols(.default = "c"))
```

Copy the source data to the repository to keep track of changes:

```{r}
write_csv(input_data, here("data", "raw", "alien_mammals_checklist_dump.csv"), na = "")
```

Preview data: 

```{r}
input_data %>% head()
```

# Preprocessing

## Tidy data

Clean data somewhat:

```{r}
input_data %<>%
  remove_empty("rows") %>%    # Remove empty rows
  clean_names()               # Have sensible (lowercase) column names
```

## Scientific names

No cleaning required.

## Taxon IDs

To link taxa with information in the extension(s), each taxon needs a unique and relatively stable `taxonID`. Here we create one in the form of `dataset_shortname:taxon:hash`, where `hash` is unique code based on scientific name and kingdom (that will remain the same as long as scientific name and kingdom remain the same):

```{r}
vdigest <- Vectorize(digest) # Vectorize digest function to work with vectors
input_data %<>% mutate(taxon_id = paste(
  "alien-mammals-checklist",
  "taxon",
  vdigest(paste(scientific_name, kingdom), algo = "md5"),
  sep = ":"
))
```


Preview data:

```{r}
input_data %>% head()
```

# Darwin Core mapping

## Taxon core

Create a dataframe with unique taxa only (ignoring multiple distribution rows):

```{r}
taxon <- input_data %>% distinct(taxon_id, .keep_all = TRUE)
```

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).
 
### language

```{r}
taxon %<>% mutate(dwc_language = "en")
```

### license

```{r}
taxon %<>% mutate(dwc_license = "http://creativecommons.org/publicdomain/zero/1.0/")
```

### rightsHolder

```{r}
taxon %<>% mutate(dwc_rightsHolder = "INBO") 
```

### accessRights

```{r}
taxon %<>% mutate(dwc_accessRights = "https://www.inbo.be/en/norms-data-use") 
```

### datasetID

```{r}
taxon %<>% mutate(dwc_datasetID = "") 
```

### institutionCode

```{r}
taxon %<>% mutate(dwc_institutionCode = "INBO") 
```

### datasetName

```{r}
taxon %<>% mutate(dwc_datasetName = "Checklist of alien mammals of Belgium") 
```

### taxonID

```{r}
taxon %<>% mutate(dwc_taxonID = taxon_id)
```

### scientificName

```{r}
taxon %<>% mutate(dwc_scientificName = scientific_name) 
```

### kingdom

```{r}
taxon %<>% mutate(dwc_kingdom = kingdom)
```

### phylum

```{r}
taxon %<>% mutate(dwc_phylum = phylum)
```

### order

```{r}
taxon %<>% mutate(dwc_order = order)
```

### family

```{r}
taxon %<>% mutate(dwc_family = family)
```

### genus

```{r}
taxon %<>% mutate(dwc_genus = genus)
```

### taxonRank

```{r}
taxon %<>% mutate(dwc_taxonRank = taxon_rank)
```

### nomenclaturalCode

```{r}
taxon %<>% mutate(dwc_nomenclaturalCode = nomenclatural_code)
```

## Distribution extension

Create a dataframe with all data (including multiple distributions):

```{r}
distribution <- input_data
```

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### taxonID

```{r}
distribution %<>% mutate(dwc_taxonID = taxon_id) 
```

### locationID

Currently map for Belgian regions only:

```{r}
distribution %<>% mutate(dwc_locationID = case_when(
  location == "Flanders" ~ "ISO_3166-2:BE-VLG",
  location == "Wallonia" ~ "ISO_3166-2:BE-WAL",
  location == "Brussels" ~ "ISO_3166-2:BE-BRU"
))
```

### locality

Currently map for Belgian regions only:

```{r}
distribution %<>% mutate(dwc_locality = case_when(
  location == "Flanders" ~ "Flemish Region",
  location == "Wallonia" ~ "Walloon Region",
  location == "Brussels" ~ "Brussels-Capital Region"
))
```

### countryCode

```{r}
distribution %<>% mutate(dwc_countryCode = "BE")
```

### occurrenceStatus

```{r}
distribution %<>% mutate(dwc_occurrenceStatus = occurrence_status)
```

### establishmentMeans

```{r}
distribution %<>% mutate(dwc_establishmentMeans = "introduced")
```


### degreeOfEstablishment

```{r}
distribution %<>% mutate(dwc_degreeOfEstablishment = degree_of_establishment) 
```

### pathway

### eventDate

Information for `eventDate` is contained in `date_first_observation` and `date_last_observation`, which we will express here in an ISO 8601 date format `yyyy/yyyy` (`start_date/end_date`).

Inspect `data_first_observation` and `date_last_observation`:

```{r}
distribution %>%
  group_by(date_first_observation, date_last_observation) %>%
  count()
```
Not all cells for `date_first_observation` and/or `date_last_observation` are populated. So, we used the following rules (`YP` = year of (re)publication of the checklist) for those records: 

***case 1.*** If `DFO` is empty and `DLO` is empty, `eventDate` is `YP/YP` 
***case 2.***  If `DFO` is empty and `DLO` is not empty: take `date_last_observation` as `date_first_observation`, eventDate = `DLO/DLO`
***case 3.*** If `DFO` is not empty and `DLO` is empty, take `YP` as `DLO`, so eventDate is `DFO/YP`

Define `current_year`

```{r}
year_publication <- format(Sys.Date(), "%Y")
```


```{r}
distribution %<>% mutate(dwc_eventDate = case_when(
  is.na(date_first_observation) & is.na(date_last_observation) ~ paste(year_publication, year_publication, sep = "/"),
  is.na(date_first_observation) & !is.na(date_last_observation) ~ paste(date_last_observation, date_last_observation, sep = "/"),
  !is.na(date_first_observation) & is.na(date_last_observation) ~ paste(date_first_observation, year_publication, sep = "/"),
  !is.na(date_first_observation) & !is.na(date_last_observation) ~ paste(date_first_observation, date_last_observation, sep = "/")
  ))

```

Check mapping:

```{r}
distribution %>%
  group_by(date_first_observation, date_last_observation, dwc_eventDate) %>%
  count()
```

### source

```{r}
distribution %<>% mutate(dwc_source = source) 
```

### occurrenceRemarks

```{r}
distribution %<>% mutate(dwc_occurrenceRemarks = remarks) 
```

## Species profile extension

In this extension we will express broad habitat characteristics of the species (e.g. `isTerrestrial`) from `realm`.

Create a dataframe with unique taxa only (ignoring multiple distribution rows):

```{r}
species_profile <- input_data %>% distinct(taxon_id, .keep_all = TRUE)
```

Only keep records for which `realm` is not empty:

```{r}
species_profile %<>% filter(!is.na(realm))
```

Inspect values:

```{r}
species_profile %>%
  group_by(realm) %>%
  count()
```

Map the data to [Species Profile](http://rs.gbif.org/extension/gbif/1.0/speciesprofile.xml).

### taxonID

```{r}
species_profile %<>% mutate(dwc_taxonID = taxon_id)
```

### isMarine

```{r}
species_profile %<>% mutate(dwc_isMarine = "FALSE") 
```

### isFreshwater

```{r}
species_profile %<>% mutate(dwc_isFreshwater = case_when(
  realm == "freshwater" ~ "TRUE",
  TRUE ~ "FALSE"
)) 
```

### isTerrestrial

```{r}
species_profile %<>% mutate(dwc_isTerrestrial = case_when(
  realm == "terrestrial" ~ "TRUE",
  TRUE ~ "FALSE"
))
```

Show mapped values:

```{r}
species_profile %>%
  select(realm, dwc_isMarine, dwc_isFreshwater, dwc_isTerrestrial) %>%
  group_by_all() %>%
  summarize(records = n())
```
## Description extension

In the description extension we want to include the species' native range. We will express native range information from `native_range`, separated and gathered.

Create a dataframe with unique taxa only (ignoring multiple distribution rows):

```{r}
native_range <- input_data %>% distinct(taxon_id, .keep_all = TRUE)
```

Separate values on `|` in a maximum of 4 columns:

```{r}
native_range %<>% separate(
  native_range,
  into = paste0("range_", c(1:4)),
  sep = " \\| ",
  extra = "drop"
)
```

Gather and trim values:

```{r}
native_range %<>% gather(key, value, starts_with("range_"), na.rm = TRUE) %>%
  mutate(value = str_trim(value))
```

Inspect values:

```{r}
native_range %>%
  group_by(value) %>%
  count()
```

Clean native range information in `value` somewhat:

```{r}
native_range %<>% 
  mutate(value = str_remove_all(value, "\\?")) %>%  # Remove question
  mutate(value = str_to_title(value))
```

Map values:

```{r}
native_range %<>% mutate(mapped_value = recode(value,
  "Africa"                 = "Africa (WGSRPD:2)",
  "Australa"               = "Australia (WGSRPD:50)",
  "Canary Islands"         = "Canary Islands (WGSRPD:21_CNY)",
  "Central America"        = "Central America (WGSRPD:80)",
  "China"                  = "China (WGSRPD:36)",
  "Costa Rica"             = "Costa Rica (WGSRPD:80_COS)",
  "Cyprus"                 = "Cyprus (WGSRPD:34_CYP)",
  "East Africa"            = "Eastern Africa",
  "East Asia"              = "Eastern Asia (WGSRPD:38)",
  "Europe"                 = "Europe (WGSRPD:1)",
  "HawaÃ¯"                  = "Hawaii (WGSRPD:63_HAW)",
  "Japan"                  = "Japan (WGSRPD:38_JAP)",
  "Mexico"                 = "Mexico (WGSRPD:79)",
  "New Zealand"            = "New Zealand (WGSRPD:51)",
  "North Amercia"          = "Northern America (WGSRPD:7)",
  "South America"          = "Southern America (WGSRPD:8)",
  "Southeastern Europe"    = "Southeastern Europe (WGSRPD:13)",
  "Southern Africa "       = "Southern Africa (WGSRPD:27)",
  "Tasmania"               = "Tasmania (WGSRPD:50_TAS)",
  "Vietnam"                = "Vietnam (WGSRPD:41_VIE)",
# .default                 = "",
  .missing                 = ""
))
```

Inspect mapped values:

```{r}
native_range %>%
  group_by(value, mapped_value) %>%
  count()
```

Drop `key` and `value` column and rename `mapped value`:

```{r}
native_range %<>% 
  select(-key, -value) %>% 
  rename(description = mapped_value)
```

Keep only non-empty descriptions:

```{r}
native_range %<>% filter(!is.na(description) & description != "")
```

Create a `type` field to indicate the type of description:

```{r}
native_range %<>% mutate(type = "native range")
```
